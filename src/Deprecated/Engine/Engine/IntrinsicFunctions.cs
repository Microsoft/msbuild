// Copyright (c) Microsoft. All rights reserved.// Licensed under the MIT license. See LICENSE file in the project root for full license information.//-----------------------------------------------------------------------// <copyright file="IntrinsicFunctions.cs" company="Microsoft">//     Copyright (c) Microsoft Corporation.  All rights reserved.// </copyright>// <summary>Definition of functions which can be accessed from MSBuild files.</summary>//-----------------------------------------------------------------------using System;using System.Collections.Generic;using System.Text;using Microsoft.Build.BuildEngine.Shared;using Microsoft.Win32;using System.IO;namespace Microsoft.Build.BuildEngine{    /// <summary>    /// The Intrinsic class provides static methods that can be accessed from MSBuild's    /// property functions using $([MSBuild]::Function(x,y))    /// </summary>    internal static class IntrinsicFunctions    {        /// <summary>        /// Add two doubles        /// </summary>        internal static double Add(double a, double b)        {            return a + b;        }        /// <summary>        /// Add two longs        /// </summary>        internal static long Add(long a, long b)        {            return a + b;        }        /// <summary>        /// <summary>        /// Escape the string according to MSBuild's escaping rules        /// </summary>        internal static string Escape(string unescaped)        {            return EscapingUtilities.Escape(unescaped);        }        /// <summary>        /// Following function will parse a keyName and returns the basekey for it.        /// It will also store the subkey name in the out parameter.        /// If the keyName is not valid, we will throw ArgumentException.        /// The return value shouldn't be null.        /// Taken from: \ndp\clr\src\BCL\Microsoft\Win32\Registry.cs        /// </summary>        private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView view, out string subKeyName)        {            if (keyName == null)            {                throw new ArgumentNullException("keyName");            }            string basekeyName;            int i = keyName.IndexOf('\\');            if (i != -1)            {                basekeyName = keyName.Substring(0, i).ToUpper(System.Globalization.CultureInfo.InvariantCulture);            }            else            {                basekeyName = keyName.ToUpper(System.Globalization.CultureInfo.InvariantCulture);            }            RegistryKey basekey = null;            switch (basekeyName)            {                case "HKEY_CURRENT_USER":                    basekey = RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, view);                    break;                case "HKEY_LOCAL_MACHINE":                    basekey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, view);                    break;                case "HKEY_CLASSES_ROOT":                    basekey = RegistryKey.OpenBaseKey(RegistryHive.ClassesRoot, view);                    break;                case "HKEY_USERS":                    basekey = RegistryKey.OpenBaseKey(RegistryHive.Users, view);                    break;                case "HKEY_PERFORMANCE_DATA":                    basekey = RegistryKey.OpenBaseKey(RegistryHive.PerformanceData, view);                    break;                case "HKEY_CURRENT_CONFIG":                    basekey = RegistryKey.OpenBaseKey(RegistryHive.CurrentConfig, view);                    break;                case "HKEY_DYN_DATA":                    basekey = RegistryKey.OpenBaseKey(RegistryHive.DynData, view);                    break;                default:                    ErrorUtilities.ThrowArgument(keyName);                    break;            }            if (i == -1 || i == keyName.Length)            {                subKeyName = string.Empty;            }            else            {                subKeyName = keyName.Substring(i + 1, keyName.Length - i - 1);            }            return basekey;        }    }}