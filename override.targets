<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <UsingTask TaskName="PrereleaseResolveNuGetPackageAssets" AssemblyFile="$(ToolsDir)Microsoft.DotNet.Build.Tasks.dll"/>

  <PropertyGroup>
    <NoStdLib Condition="'$(NetCoreBuild)'=='true'">true</NoStdLib>
    <ResolveAssemblyReferencesDependsOn>$(ResolveAssemblyReferencesDependsOn);ResolveNuGetPackageAssets</ResolveAssemblyReferencesDependsOn>
    <ProjectLockFile Condition="'$(ProjectLockFile)' == ''">project.lock.json</ProjectLockFile>
  </PropertyGroup>

  <Target Name="ResolveNuGetPackageAssets" Condition="Exists('$(ProjectLockFile)') and '$(OsEnvironment)'!='Windows_NT'">
    <PropertyGroup>
      <_ExplicitReference/>
      <!-- Under mono, the PrereleaseResolveNuGetPackageAssets will not realize that some
           dependencies are available in the framework, so it will provide references to
           the identical from the nuget cache. This causes multiple references during compile.
           In cases where we compile for CoreCLR, everything comes from the NuGet cache and
           we need to include transitive dependencies. When building for installed framework
           (such as full framework on Windows or Mono on *nix), we expect nothing from the NuGet
           cache, so we just want the task to get explicitly specified dependencies.
      -->
      <_OmitTransitiveReferences Condition="'$(NetCoreBuild)'=='true'">false</_OmitTransitiveReferences>
      <_OmitTransitiveReferences Condition="'$(NetCoreBuild)'!='true'">true</_OmitTransitiveReferences>
    </PropertyGroup>
    <PrereleaseResolveNuGetPackageAssets Condition="'$(ProjectLockFile)' != ''"
                               AllowFallbackOnTargetSelection="false"
                               IncludeFrameworkReferences="true"
                               ProjectLanguage="C#"
                               ProjectLockFile="$(ProjectLockFile)"
                               TargetMonikers="$(NuGetTargetMoniker)"
                               OmitTransitiveCompileReferences="$(_OmitTransitiveReferences)">

      <Output TaskParameter="ResolvedAnalyzers" ItemName="Analyzer" />
      <Output TaskParameter="ResolvedCopyLocalItems" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="ResolvedReferences" ItemName="_ReferencesFromNuGetPackages" />
      <Output TaskParameter="ReferencedPackages" ItemName="ReferencedNuGetPackages" />
    </PrereleaseResolveNuGetPackageAssets>

    <!-- Settings below were copied directly from the VisualStudio targets that use ResolveNuGetPackageAssets.
         Once we have a portable version of the task, we can remove this override and items/properties below.
    -->
    <ItemGroup>
      <!-- Remove exact references, such as if a package had a framework reference to 'System' that we already have -->
      <Reference Remove="@(_ReferencesFromNuGetPackages)" />

      <!-- Remove simple name references if we're directly providing a reference assembly to the compiler. For example,
           consider a project with an Reference Include="System", and some NuGet package is providing System.dll -->
      <Reference Remove="%(_ReferencesFromNuGetPackages.FileName)" />

      <!-- Remove simple name references that are already implicitly added -->
      <_ReferencesFromNuGetPackages Remove="%(ReferencePath.FileName)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />

      <Reference Include="@(_ReferencesFromNuGetPackages)" />
    </ItemGroup>
    <PropertyGroup Condition=" '$(AutoUnifyAssemblyReferences)' == 'true' ">
      <!-- Normally Design Time Assembly Resolution (DTAR) won't consider these references.
           Put DTAR in a mode where it will prefer the output of RAR and unify. -->
      <DTARUseReferencesFromProject>true</DTARUseReferencesFromProject>
    </PropertyGroup>
  </Target>
</Project>
